### Explore
source("SimFuns.R")
source("UtilityFuns.R")
load("./data/Real_Cell_Subj_Props.rda")
load("./data/Real_alpha.rda")
load("./data/Sim_tau_gk.rda")
library(gtools) 
library(scTenifoldNet)

N = 16; # number of subjects
K = 4   # number of cell types
ncells = 10000  # number of cells in total
 
ic = 14
CTs = AllPossComb[ic, ] ### one specific setting for cell type proportions 
                        ### can also be the setting from compositions indexed by c(1, 5, 17, 27) in addition to 14
                        ### "AllPossComb" contains in total 35 different combinations
CP = cellProp[CTs]/sum(cellProp[CTs]) # rescale cell type proportions


LFCBy = "Delta_gk"  ## simulate LFC directly based the estimated value from real data

NC.D = SimPara(nCells = ncells, 
               nGenes = nrow(alpha.diffSubs),
               N = N, K = K,
               Subj.Prop = SubjProp.ByTCell,  ### proportion of cells within each subject, based on real data
               CT.Prop = CP, 
               pi_k = rep(0.05, K),  ### proportion of CTS markers for each cell type
               multiCT.Marker = TRUE, ### allow one gene to be the marker of multiple cell types
               seed = 12345)
### simulate LFC (i.e., m_gk in the paper) directly based the estimated values from real data
load("./data/Res_lupus_onlyCtrl.rda")
m_gk = SimMeanLFC( D_gk = NC.D$D_gk, CTs = CTs, 
                   Delta_Gk = Delta_gk, seed = 12345)

### simulate prevalence as a function of m_gk observed from real data
Q_gk = SimPrevalenceByLFC(m_gk = m_gk, 
                          ctypes = CTs, 
                          Downrate = 1)

### modify Q_gk to guarantee that the CTS marker show DE in at least one subject 
set.seed(12345)
for (ct.ix in 1:4) {
  this.id = which(NC.D$D_gk[, ct.ix] == 1)
  ii = which(Q_gk[this.id, ct.ix] <= 1/N)
  if(length(ii) > 0){
    tmp = rbeta(length(ii), 2, 14)#runif(length(ii), 1/16, 2/16)
    tmp[tmp < 1/N] = 1/N
    Q_gk[this.id[ii], ct.ix] = tmp 
  }
}
###

######################################################################
### start to simulate count 
res.sim = SimData(NC = NC.D$NC,
                  D_gk = NC.D$D_gk , 
                  alpha = alpha.diffSubs,
                  m_gk = m_gk, 
                  tau_gk = tau_gk,
                  q_gk = Q_gk,
                  multiCT.Marker = TRUE,
                  seed = 12345)
######################################################################

######################################################################
### 1. Apply scCTS method to solve the model
source("Esti_Funs.R")
source("EMAlgorithm_Funs.R")
counts.norm = sweep(assay(res.sim$Counts.wide), 2,
                    res.sim$Counts.wide$sf, FUN = "/")
colnames(counts.norm) = res.sim$Counts.wide$celltype
dat.exp <- counts.norm 
subjects = res.sim$Counts.wide$subject
celltypes = res.sim$Counts.wide$celltype
dat.info <- loop_samples(dat.exp = dat.exp,
                         subject_info = as.character(subjects),
                         celltype_info = as.character(celltypes),
                         logcpm.input = F, numCores = 4)
dat.info.sum <- marker_summarization(dat.info)
res.marker <- csmarker_moment(dat.info.sum = dat.info.sum,
                              tol = 1e-5, numCores = 4, 
                              min.q = 1/N,
                              min.cutoff = 0.05, max.cutoff = 0.95)


CTS.PostProb = matrix(NA, nrow = nrow(res.sim$FullParas$mu), ncol = K)
for (ct.ix in 1:K) {
  D_g = res.sim$FullParas$D_gk[, ct.ix]
  pp_d = rep(NA, length(D_g)); names(pp_d) = names(D_g)
  keep.idx = rownames(res.marker[[ct.ix]]$param)
  pp_d[keep.idx] = res.marker[[ct.ix]]$pp.d1
  CTS.PostProb[, ct.ix] = pp_d
}


######################################################################
#### 2. Apply Wilcoxon-rank-sum test
source("runBaselineMethod.R")
library(data.table)
res.wilcox = BaselineMethod.wilcox(expr = counts.norm, 
                                   celltypes = colData(res.sim$Counts.wide)$celltype, 
                                   nCores.used = 2)

######################################################################
### 3. Apply NBWaVe+DESeq2, too slow
# t1 = Sys.time()
# sub.count = assay(res.sim$Counts.wide)[,1:500]
# sub.celltype = colData(res.sim$Counts.wide)$celltype[1:500]
# 
# res.NBWave_DEseq2 = BaselineMethod.DEseq2(expr = sub.count, #assay(res.sim$Counts.wide), 
#                                           celltypes = sub.celltype,#colData(res.sim$Counts.wide)$celltype, 
#                                           nCores.used = 2) 
# t2 = Sys.time()
# t2-t1
# ### too slow


######################################################################
### 4. Apply NSforest: rank genes for each cell type, ROC can be generated by ranks
library(reticulate)

reticulate::use_python(required = T,
                       python = "/Users/zhenxingguo/opt/anaconda3/bin")
library(readr)
library(purrr)
library(dplyr)
celltype.ngenes = vector("list", length = 4)
names(celltype.ngenes) = unique(colData(res.sim$Counts.wide)$celltype)
celltype.ngenes$CellType_1 = nrow(res.sim$FullParas$D_gk)
celltype.ngenes$CellType_2 = nrow(res.sim$FullParas$D_gk)
celltype.ngenes$CellType_3 = nrow(res.sim$FullParas$D_gk)
celltype.ngenes$CellType_4 = nrow(res.sim$FullParas$D_gk)
res.NSforest = BaselineMethod.NSforest(expr = assay(res.sim$Counts.wide),
                                       celltypes = colData(res.sim$Counts.wide)$celltype,
                                       celltype.ngenes = celltype.ngenes
                                       ,python.path =  "/Users/zhenxingguo/opt/anaconda3/bin")

rank.CT = matrix(NA, ncol = 4, nrow = nrow(counts.norm) )
colnames(rank.CT) = paste0("Celltype_", 1:4)
for (ict in 1:4) {
  tmp.GeneID  = as.numeric(unlist(lapply(strsplit(res.NSforest[[ict]],
                                               split = "_"),
                                      function(x) x[2])))
  tmp.rank = data.frame(Gene.ID = tmp.GeneID, Gene.rank = 1:length(tmp.GeneID))
  rank.CT[, ict] = tmp.rank[order(tmp.rank$Gene.ID), ]$Gene.rank
}
res.NSforest$GeneRank = rank.CT




######################################################################
########### Plot ROC
method.col = c("red", "blue", "green")
names(method.col) = c("scCTS", "Wilcoxon", "NSforest")
par(mfrow = c(2,2), mai = c(0.8, 0.8, 0.2, 0.2))
for (ct.ix in 1:4) {
  Plot_ROC(flag = as.logical(res.sim$FullParas$D_gk[, ct.ix]), 
           Pvals = list(
             scCTS = 1 - CTS.PostProb[, ct.ix], 
             Wilcoxon =  res.wilcox$wilcox.pval_info[, ct.ix, 1], 
             NSforest = rank.CT[, ct.ix]
             ),
           models = c("scCTS", "Wilcoxon", "NSforest"),
           cols = method.col[c("scCTS", "Wilcoxon", "NSforest")],
           ltypes = c(1, 2, 3),
           leg = TRUE)
  title(main = paste0("Celltype_", ct.ix), line = 0.3)
}  

######################################################################
#### calculate power
T0 = c(0.25, 0.5, 0.75, 0.95)
scCTS.FDR = scCTS.Power = scCTS.TypeIe = matrix(NA, nrow = 4, ncol = length(T0))
rownames(scCTS.FDR) = rownames(scCTS.Power) = rownames(scCTS.TypeIe) = paste0("CT", 1:4)
colnames(scCTS.FDR) = colnames(scCTS.Power) = colnames(scCTS.TypeIe) = c("0.25", "0.5", "0.75","0.95")
Wilcoxon.FDR = Wilcoxon.Power = Wilcoxon.TypeIe = rep(NA, 4)

for (ct.ix in 1:4) {
  for (it in 1:length(T0)) {
    t0 = T0[it]
    scCTS.FDR[ct.ix, it] = sum(CTS.PostProb[, ct.ix] > t0 &  res.sim$FullParas$D_gk[, ct.ix] == 0
                                   , na.rm = TRUE)/sum(CTS.PostProb[, ct.ix] > t0, na.rm = TRUE)
    scCTS.Power[ct.ix, it] = sum(CTS.PostProb[, ct.ix] > t0 & res.sim$FullParas$D_gk[, ct.ix] == 1
                                     , na.rm = TRUE)/sum(res.sim$FullParas$D_gk[, ct.ix]  == 1, na.rm = TRUE)
    
    scCTS.TypeIe[ct.ix, it] = sum(CTS.PostProb[, ct.ix] > t0 & res.sim$FullParas$D_gk[, ct.ix]  == 0
                                      , na.rm = TRUE)/sum(res.sim$FullParas$D_gk[, ct.ix]  == 0, na.rm = TRUE)
  }
  Wilcoxon.pval =  res.wilcox$wilcox.pval_info[, ct.ix, 1]
  
  Wilcoxon.padj = p.adjust(Wilcoxon.pval, method = "fdr")
  Wilcoxon.FDR[ct.ix] = sum(Wilcoxon.padj < 0.05 & res.sim$FullParas$D_gk[, ct.ix] == 0
                                  , na.rm = TRUE)/sum(Wilcoxon.padj < 0.05, na.rm = TRUE)
  Wilcoxon.Power[ct.ix] = sum(Wilcoxon.padj < 0.05 & res.sim$FullParas$D_gk[, ct.ix] == 1
                                    , na.rm = TRUE)/sum(res.sim$FullParas$D_gk[, ct.ix] == 1, na.rm = TRUE)
  Wilcoxon.TypeIe[ct.ix] = sum(Wilcoxon.pval < 0.05 &res.sim$FullParas$D_gk[, ct.ix] == 0
                                     , na.rm = TRUE)/sum(res.sim$FullParas$D_gk[, ct.ix] == 0, na.rm = TRUE)

  }


